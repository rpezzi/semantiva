Data Processors
===============

Overview
--------

- :py:class:`semantiva.data_processors.data_processors.DataOperation`: transforms data
- :py:class:`semantiva.data_processors.data_processors.DataProbe`: inspects/records
- :py:class:`semantiva.data_processors.data_processors.OperationTopologyFactory` and slicing utilities
- :py:class:`semantiva.data_processors.parametric_sweep_factory.ParametricSweepFactory`: engine behind :doc:`sweeps` (``derive.parameter_sweep``). Variables are declared with :py:class:`~semantiva.data_processors.parametric_sweep_factory.RangeSpec`, :py:class:`~semantiva.data_processors.parametric_sweep_factory.SequenceSpec`, and :py:class:`~semantiva.data_processors.parametric_sweep_factory.FromContext`; modes ``combinatorial`` and ``by_position`` are supported.

**Important**: All processor parameters must be explicitly declared in the ``_process_logic`` signature.
`**kwargs` is not allowed for reliable provenance tracking. Each parameter must be individually named
to ensure proper parameter resolution and inspection.

Parameter Validation Examples
-----------------------------

Valid Parameter Patterns
~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: python

   from semantiva.data_processors import DataOperation

   class ValidProcessor(DataOperation):
       def _process_logic(self, data, factor: float, threshold: float = 0.5):
           # ✅ All parameters explicitly declared
           return data.apply_transformation(factor, threshold)

Invalid Parameter Patterns (Rejected)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: python

   # ❌ This will raise ValueError during introspection
   class InvalidProcessor(DataOperation):
       def _process_logic(self, data, **kwargs):
           # This pattern is rejected for provenance reliability
           pass

Exception: Parametric Sweep Processors
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Only certain factory-generated processors are allowed to use `**kwargs`:

.. code-block:: python

   # ✅ This is allowed - generated by ParametricSweepFactory
   class ParametricSweepSomeProcessor(DataOperation):
       def _process_logic(self, data, **kwargs):
           # This works because class name contains "ParametricSweep"
           pass

Examples
--------

derive.parameter_sweep variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The :py:class:`~semantiva.data_processors.parametric_sweep_factory.ParametricSweepFactory`
drives :doc:`sweeps` by turning the ``variables`` mapping into typed objects:

- :py:class:`~semantiva.data_processors.parametric_sweep_factory.RangeSpec`
  produces numeric ranges with optional logarithmic spacing and endpoint
  control.
- :py:class:`~semantiva.data_processors.parametric_sweep_factory.SequenceSpec`
  wraps explicit sequences (numbers, strings, paths, etc.).
- :py:class:`~semantiva.data_processors.parametric_sweep_factory.FromContext`
  reads a sequence from ``payload.context`` at runtime and exposes the
  required key to inspection.

Each variable becomes available to expressions declared under
``derive.parameter_sweep.parameters``.

Expressions for computed parameters
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Expressions execute under a safe evaluator. Keys inside the
``parameters`` mapping **must** match the callee's parameter names. Any
unknown name raises an error during preprocessing and inspection.

Modes
~~~~~

``derive.parameter_sweep`` supports ``combinatorial`` (Cartesian product) and
``by_position`` (zip-style alignment) modes. ``broadcast: true`` repeats shorter
sequences for ``by_position`` sweeps.

**Performance tip**: combinatorial mode scales with the product of variable
lengths; monitor run-space size carefully for large grids.

**YAML Configuration (derive boundary)**

Configure parametric sweeps using the ``derive.parameter_sweep`` preprocessor:

.. code-block:: yaml

   pipeline:
     nodes:
       - processor: ModelDataSource
         derive:
           parameter_sweep:
             parameters:
               learning_rate: 10 ** p
             variables:
               p: { lo: -3, hi: -1, steps: 3 }
             mode: combinatorial
             collection: ResultCollection

Data operations use the same pattern and **require** ``collection``:

.. code-block:: yaml

   - processor: FloatMultiplyOperation
     derive:
       parameter_sweep:
         parameters:
           factor: f
         variables:
           f: [0.5, 1.0, 2.0]
         mode: by_position
         collection: FloatDataCollection

Probes omit ``collection`` and persist results via the node-level ``context_key``:

.. code-block:: yaml

   - processor: FloatCollectValueProbe
     derive:
       parameter_sweep:
         parameters: {}
         variables:
           t: { lo: 0, hi: 2, steps: 3 }
     context_key: sweep_probe_results

Runnable example
~~~~~~~~~~~~~~~~

Copy :download:`pipeline_sweep_parameters_first.yaml
<examples/pipeline_sweep_parameters_first.yaml>` and run:

.. code-block:: bash

   semantiva run pipeline_sweep_parameters_first.yaml -v

Inspection reports computed parameters, the variable values published to
context, and any ``required_external_parameters`` that remain.

FromContext variable specification
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The :py:class:`~semantiva.data_processors.parametric_sweep_factory.FromContext`
specification enables sweeps over sequences discovered at runtime. Use this when
sweep values are produced by earlier pipeline stages or provided via CLI context.

**Minimal example:**

.. literalinclude:: ../../semantiva/examples/from_context_sweep_demo.yaml
   :language: yaml
   :caption: FromContext sweep demo

Run with:

.. code-block:: bash

   semantiva run semantiva/examples/from_context_sweep_demo.yaml --context discovered_values='[1.3, 2.5, 3.7]'

**Behavior:**

- The sweep reads the ``discovered_values`` context key at runtime
- Validates it contains a non-empty, non-string sequence
- Creates ``input_value_values`` in context for downstream processors
- Invokes the processor once per sequence item
- Produces a typed collection (``FloatDataCollection``)

**Inspection:**

The processor exposes ``discovered_values`` via ``get_context_requirements()``,
allowing inspection tools to report missing dependencies before execution.

**Provenance Tracking:**

All parameters, including those derived from ``FromContext`` variables, are tracked
with full provenance in Semantic Execution Records (SER). The trace records show:

- The actual runtime values in ``processor.parameters``
- The origin in ``processor.parameter_sources`` (``"context"`` for FromContext variables)
- Context reads/writes in ``context_delta`` (created ``{var}_values`` sequences)

See :doc:`sweeps` for comprehensive details on parameter provenance tracking.

Autodoc
-------

.. automodule:: semantiva.data_processors.data_processors
   :members:
   :undoc-members:
   :show-inheritance:

.. automodule:: semantiva.data_processors.data_slicer_factory
   :members:
   :undoc-members:

.. automodule:: semantiva.data_processors.parametric_sweep_factory
   :members:
   :undoc-members:
